#!/bin/bash
# =============================================================================
# Palworld Backup - Automated backup of save files
# =============================================================================

# Don't use set -e - handle errors explicitly for better diagnostics

# Source common functions
if ! source /opt/palworld/scripts/common; then
    echo "[ERROR] Failed to source common functions"
    exit 1
fi

# Parse arguments
FORCE_BACKUP=false
for arg in "$@"; do
    case ${arg} in
        --force)
            FORCE_BACKUP=true
            ;;
    esac
done

# -----------------------------------------------------------------------------
# Create backup
# -----------------------------------------------------------------------------
create_backup() {
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)

    local backup_name="palworld_${timestamp}"
    local backup_dir="${BACKUPS_PATH}"

    log_info "=========================================="
    log_info "Creating backup: ${backup_name}"
    log_info "=========================================="

    # Ensure backup directory exists
    mkdir -p "${backup_dir}"

    # Find save files
    local save_dir="${SAVES_PATH}"
    local settings_dir="${SETTINGS_PATH}"

    if [[ ! -d "${save_dir}" ]] && [[ ! -d "${settings_dir}" ]]; then
        log_warn "No save or settings files found"
        log_warn "Save path: ${save_dir}"
        log_warn "Settings path: ${settings_dir}"
        ls -la "${PALWORLD_SERVER_PATH}/Pal/Saved" 2>/dev/null || true
        return 1
    fi

    # Create temporary directory for backup
    local temp_dir
    temp_dir=$(mktemp -d)
    local backup_content_dir="${temp_dir}/${backup_name}"
    mkdir -p "${backup_content_dir}"

    # Copy save files
    local files_copied=0

    if [[ -d "${save_dir}" ]]; then
        cp -r "${save_dir}" "${backup_content_dir}/SaveGames"
        log_info "Copied: SaveGames directory"
        files_copied=$((files_copied + 1))
    fi

    if [[ -d "${settings_dir}" ]]; then
        cp -r "${settings_dir}" "${backup_content_dir}/Config"
        log_info "Copied: Config directory"
        files_copied=$((files_copied + 1))
    fi

    if [[ ${files_copied} -eq 0 ]]; then
        log_error "No files to backup"
        rm -rf "${temp_dir}"
        return 1
    fi

    # Create backup (zip or tar)
    local backup_use_zip="${BACKUPS_ZIP:-true}"
    local backup_file

    if [[ "${backup_use_zip,,}" == "true" ]]; then
        backup_file="${backup_dir}/${backup_name}.zip"
        log_info "Creating ZIP backup: ${backup_file}"
        cd "${temp_dir}"
        zip -r "${backup_file}" "${backup_name}"
    else
        backup_file="${backup_dir}/${backup_name}.tar.gz"
        log_info "Creating TAR backup: ${backup_file}"
        cd "${temp_dir}"
        tar -czf "${backup_file}" "${backup_name}"
    fi

    # Cleanup temp directory
    rm -rf "${temp_dir}"

    # Get backup size
    local backup_size
    backup_size=$(du -h "${backup_file}" | cut -f1)

    log_success "Backup created: ${backup_file} (${backup_size})"

    return 0
}

# -----------------------------------------------------------------------------
# Cleanup old backups
# -----------------------------------------------------------------------------
cleanup_old_backups() {
    local max_age="${BACKUPS_MAX_AGE:-3}"
    local max_count="${BACKUPS_MAX_COUNT:-0}"
    local backup_dir="${BACKUPS_PATH}"

    log_info "Cleaning up old backups (max_age=${max_age} days, max_count=${max_count})"

    # Remove backups older than max_age days
    if [[ ${max_age} -gt 0 ]]; then
        local deleted_age=0
        while IFS= read -r -d '' file; do
            log_info "Removing old backup: $(basename "${file}")"
            rm -f "${file}"
            deleted_age=$((deleted_age + 1))
        done < <(find "${backup_dir}" -maxdepth 1 -name "palworld_*.zip" -o -name "palworld_*.tar.gz" -mtime +${max_age} -print0 2>/dev/null)

        if [[ ${deleted_age} -gt 0 ]]; then
            log_info "Removed ${deleted_age} backups older than ${max_age} days"
        fi
    fi

    # Keep only max_count backups
    if [[ ${max_count} -gt 0 ]]; then
        local backup_count
        backup_count=$(find "${backup_dir}" -maxdepth 1 \( -name "palworld_*.zip" -o -name "palworld_*.tar.gz" \) 2>/dev/null | wc -l)

        if [[ ${backup_count} -gt ${max_count} ]]; then
            local to_delete=$((backup_count - max_count))
            log_info "Removing ${to_delete} excess backups (keeping ${max_count})"

            find "${backup_dir}" -maxdepth 1 \( -name "palworld_*.zip" -o -name "palworld_*.tar.gz" \) -printf '%T@ %p\n' 2>/dev/null \
                | sort -n \
                | head -n ${to_delete} \
                | cut -d' ' -f2- \
                | while read -r file; do
                    log_info "Removing: $(basename "${file}")"
                    rm -f "${file}"
                done
        fi
    fi
}

# -----------------------------------------------------------------------------
# Main backup logic
# -----------------------------------------------------------------------------
main() {
    # Check if backups are enabled
    if ! is_backups_enabled && [[ "${FORCE_BACKUP}" != "true" ]]; then
        log_info "Backups are disabled"
        return 0
    fi

    # Check if we should skip due to server being idle
    local backup_if_idle="${BACKUPS_IF_IDLE:-false}"
    if [[ "${backup_if_idle,,}" == "true" ]] && [[ "${FORCE_BACKUP}" != "true" ]]; then
        if is_server_running && ! is_server_idle; then
            log_info "Skipping backup while players are connected (BACKUPS_IF_IDLE=true)"
            return 0
        fi
    fi

    # Create backup
    if create_backup; then
        # Cleanup old backups
        cleanup_old_backups
        log_success "Backup process completed"
    else
        log_error "Backup process failed"
        return 1
    fi

    return 0
}

# Run main
main
